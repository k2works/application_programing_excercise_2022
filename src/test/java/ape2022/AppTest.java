/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ape2022;

import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestClassOrder;
import org.junit.jupiter.api.io.TempDir;
import org.junit.jupiter.engine.discovery.predicates.IsInnerClass;
import org.junit.platform.engine.support.discovery.SelectorResolver.Match;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Path;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.text.ParseException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.IllegalFormatConversionException;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Random;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import javax.net.SocketFactory;
import javax.net.ssl.SSLSocketFactory;

import java.time.*;

class AppTest {

    @Nested
    class 値と計算 {
        @Nested
        class 値と演算 {
            @Test
            void 整数() {
                assertEquals(7, 5 + 2);
                assertEquals(10, 5 * 2);
                assertEquals(3, 5 - 2);
                assertEquals(2, 5 / 2);
                assertEquals(14, 2 + 3 * 4);
                assertEquals(20, (2 + 3) * 4);
                assertEquals(1, 5 % 2);

            }

            @Test
            void 構文エラー() {

            }

            @Test
            void 実数() {
                assertEquals(7.0, 5.0 + 2);
                assertEquals(2.5, 5.0 / 2);

            }

            @Test
            void 文字列() {
                assertEquals("tester", "test" + "er");
                assertEquals("test123", "test" + "123");
                assertEquals("test123", "test" + 12 + 3);
                assertEquals("test15", "test" + (12 + 3));
                assertEquals("15test", 12 + 3 + "test");
                assertEquals("52", "5" + 2);

                assertEquals("文字列に\"を含む", "文字列に\"を含む");
                assertEquals("改行\nする", "改行\nする");

                var text = """
                        test
                        foo
                        """;
                assertEquals(text, "test\nfoo\n");

            }

            @Test
            void 例外() {

                CalcInterface calc = (a, b) -> a / b;
                assertThrows(ArithmeticException.class, () -> calc.div(3, 0));
            }
        }

        @Nested
        class メソッドの呼び出し {
            @Test
            void メソッドの呼び出し() {
                assertEquals("TEST", "TEST".toUpperCase());
                assertEquals(4, "test".length());
            }

            @Test
            void 文字列の掛け算や引き算() {
                assertEquals("testtesttest", "test".repeat(3));
                assertEquals("testtesttesttesttest", "test".repeat(5));
                assertEquals("tt", "test".replace("es", ""));
            }

            @Test
            void メソッドのシグネチャ() {

            }

            @Test
            void メソッドの使い方がわからないとき() {

            }

            @Test
            void 文字列のフォーマット() {

                assertEquals("test15", "test%s".formatted(12 + 3));
                assertEquals("testとsample", "%sと%s".formatted("test", "sample"));
                assertEquals("2+3=5", "%d+%d=%d".formatted(2, 3, 2 + 3));
                assertEquals("消費税抜き1,000円は消費税込みで1,100円", "消費税抜き%,d円は消費税込みで%,d円".formatted(1000, 1100));
            }

            @Test
            void formattedメソッドでの例外() {
                assertThrows(IllegalFormatConversionException.class, () -> "%d+%d".formatted("abc", "cde"));
            }
        }
    }

    @Nested
    class 変数と型 {
        @Nested
        class 変数 {
            @Test
            void 変数() {
                var t = "test";
                assertEquals("test", t);
                assertEquals("test3", t + "3");
                assertEquals("TEST", t.toUpperCase());
                t = "real";
                assertEquals("real3", t + "3");
                assertEquals("REAL", t.toUpperCase());
            }

            @Test
            void 複合代入演算子() {
                var n = 20;
                n *= 5;
                assertEquals(100, n);

                var c = "te";
                c += "st";
                assertEquals("test", c);

                n = 100;
                assertEquals(101, ++n);
                n = 100;
                assertEquals(100, n++);
            }

            @Test
            void 値に名前を付けるメリット() {
                var test = "test";
                assertEquals("test", test);
                assertEquals("TEST", test.toUpperCase());
                var rest = "rest";
                assertEquals("REST", rest.toUpperCase());
                var r10 = 11.75;
                assertEquals(11.75, r10);
                assertEquals(433.51625, r10 * r10 * 3.14);
                assertEquals(433.73613573624084, r10 * r10 * Math.PI);
            }

        }

        @Nested
        class 型 {
            @Test
            void 変数の型() {
                var t = "real";
                assertTrue(t instanceof String);
                var i = 5;
                assertTrue((Integer) i instanceof Integer);
            }

            @Test
            void 基本型と参照型() {
                String u = "myname";
                assertTrue(u instanceof String);
            }

            @Test
            void 文字を扱う型() {
                char ch = 48;
                assertEquals('0', ch);
                ch = '0' + 9;
                assertEquals('9', ch);
                assertEquals(8, '8' - '0');
                ch = 'A' + 32;
                assertEquals('a', ch);
            }

            @Test
            void 数値の型変換() throws ParseException {
                int i = 234;
                double d = i;
                assertEquals(234.0, d);
                int j = (int) d;
                assertEquals(234, j);
                d = 3.14;
                i = (int) d;
                assertEquals(3, i);
                d = i;
                assertEquals(3.0, d);
                assertEquals(-3, (int) -3.14);

                int a = Integer.parseInt("3");
                assertEquals(3, a);
                assertThrows(NumberFormatException.class, () -> Integer.parseInt("3a"));
                d = Double.parseDouble("12.3");
                assertEquals(12.3, d);
                assertEquals(12345, java.text.NumberFormat.getInstance().parse("12,345").intValue());

                String s = 123 + "";
                assertEquals("123", s);
                assertEquals("123", String.valueOf(123));
                assertEquals("12,345", "%,d".formatted(12345));
                assertEquals("12,345", java.text.NumberFormat.getInstance().format(12345));
            }

            @Test
            void 型の役割() {

            }

        }
    }

    @Nested
    class 標準API {
        @Nested
        class 日付時刻 {
            @Test
            void 現在日時を取得する() {
                var nowDay = java.time.LocalDate.now();
                // assertEquals(nowDay, java.time.LocalDate.now());
                var nowTime = java.time.LocalTime.now();
                // assertEquals(nowTime, java.time.LocalTime.now());
                var nowDateTime = java.time.LocalDateTime.now();
                // assertEquals(nowDateTime, java.time.LocalDateTime.now());
            }

            @Test
            void 日付時刻の操作() {
                var threeDaysAfter = LocalDate.now().plusDays(3);
                assertEquals(threeDaysAfter, LocalDate.now().plusDays(3));
                var today = LocalDateTime.now();
                var twoWeeksLater = today.plusWeeks(2);
                assertEquals(twoWeeksLater, today.plusWeeks(2));
                var twoHoursLater = today.plusHours(2);
                assertEquals(twoHoursLater, today.plusHours(2));
            }

            @Test
            void 指定した日付時刻を扱う() {
                var java17date = LocalDate.of(2021, 9, 14);
                assertEquals(java17date, LocalDate.of(2021, 9, 14));
                var java17time = LocalTime.of(14, 30);
                assertEquals(java17time, LocalTime.of(14, 30));
                var java17dateTime = LocalDateTime.of(java17date, java17time);
                assertEquals(java17dateTime, LocalDateTime.of(java17date, java17time));
                var java16dateTime = LocalDateTime.of(2021, 3, 16, 14, 30);
                assertEquals(java16dateTime, LocalDateTime.of(2021, 3, 16, 14, 30));
            }

            @Test
            void 日付時刻の整形() {
                assertEquals("06月", "%tm月".formatted(LocalDate.of(2021, 6, 1)));
                assertEquals("01時35分",
                        "%tH時%tM分".formatted(LocalDateTime.of(2021, 6, 1, 1, 35), LocalDateTime.of(2020, 6, 1, 1, 35)));
                assertEquals("01時35分",
                        "%tH時%<tM分".formatted(LocalDateTime.of(2022, 6, 1, 1, 35)));
                assertEquals("2021年06月25日", "%tY年%<tm月%<td日".formatted(LocalDate.of(2021, 6, 25)));
            }

            @Test
            void staticメソッドとインスタンスメソッド() {
                assertEquals("testとsample", String.format("%sと%s", "test", "sample"));
                assertEquals("みかん", "%sですよ".format("みかん"));
                assertEquals("みかんですよ", "%sですよ".formatted("みかん"));
            }
        }

        @Nested
        class BigDecimal_ {
            @Test
            void BigDecimalでの計算() {
                assertEquals(28.95, BigDecimal.valueOf(579).multiply(BigDecimal.valueOf(0.05)).doubleValue());
                var b579 = BigDecimal.valueOf(579);
                assertEquals(579, b579.doubleValue());
                var b005 = BigDecimal.valueOf(0.05);
                assertEquals(0.05, b005.doubleValue());
                assertEquals(28.95, b579.multiply(b005).doubleValue());
                var result = b579.divideAndRemainder(BigDecimal.valueOf(100));
                assertEquals(5, result[0].intValue());
                assertEquals(79, result[1].intValue());
            }

            @Test
            void newによるBigDecimalオブジェク生成() {
                assertEquals(3.141592653589793, BigDecimal.valueOf(3.141592653589793238).doubleValue());
                assertEquals(3.141592653589793238, new BigDecimal("3.141592653589793238").doubleValue());
            }

            @Test
            void BigDecimalオブジェク生成時の注意() {
                assertEquals(0.625, new BigDecimal(0.625).doubleValue());
            }
        }
    }

    @Nested
    class 条件分岐 {
        @Nested
        class 論理型 {
            @Test
            void 論理型() {
                assertTrue("test".contains("es"));
                assertFalse("test".contains("a"));
            }

            @Test
            void 値の比較() {
                assertTrue(3 < 4);
                assertFalse(4 < 3);
                assertTrue(4 == 4);
                assertFalse(3 == 4);
                assertFalse(4 != 4);
                assertTrue(3 != 4);
            }

            @Test
            void オブジェクトの大小比較() {
                assertEquals(-1, "apple".compareTo("banana"));
                var today = LocalDate.of(2021, 9, 24);
                var java17 = LocalDate.of(2021, 9, 14);
                assertEquals(10, today.compareTo(java17));
                assertTrue(today.isAfter(java17));
                assertFalse(today.isBefore(java17));
            }

            @Test
            void オブジェクトが等しいかどうかの比較() {
                assertTrue("test" == "test");
                assertFalse("test" == "TEST");
                var str = "TEST".toLowerCase();
                assertFalse(str == "test");
                assertTrue(str.equals("test"));
                var java17 = LocalDate.of(2021, 9, 14);
                assertFalse(java17.plusDays(5) == LocalDate.of(2021, 9, 19));
                assertTrue(java17.plusDays(5).equals(LocalDate.of(2021, 9, 19)));
            }

            @Test
            void 論理演算子() {
                assertTrue(true || false);
                assertFalse(false || false);
                assertTrue(true && true);
                assertFalse(true && false);
                var a = 5;
                assertTrue(3 <= a && a <= 7);
                a = 1;
                assertFalse(3 <= a && a <= 7);
                a = 8;
                assertFalse(3 <= a && a <= 7);
                assertTrue(a < 3 || 7 < a);
                a = 1;
                assertTrue(a < 3 || 7 < a);
                a = 5;
                assertFalse(a < 3 || 7 < a);
                assertFalse(!true);
                assertTrue(!false);
                assertFalse(!"test".contains("es"));
                assertTrue(!"test".contains("a"));
            }

            @Test
            void 条件演算子() {
                var a = 3;
                assertEquals("small", a < 5 ? "small" : "big");
                a = 7;
                assertEquals("big", a < 5 ? "small" : "big");
                assertEquals("high", a < 3 ? "low" : a < 7 ? "middle" : "high");
                var message = a < 3 ? "low" : a < 7 ? "middle" : "high";
                assertEquals("high", message);
            }
        }

        @Nested
        class if文による条件分岐 {
            @Test
            void if文() {
                StateMentInterface ifState = (args) -> {
                    var a = 2;
                    if (a < 3) {
                        return "小さい";
                    }
                    return "大きい";
                };

                assertEquals("小さい", ifState.main(new String[0]));
            }

            @Test
            void else句() {
                StateMentInterface elseState = (args) -> {
                    var a = 2;
                    if (a < 3) {
                        return "小さい";
                    } else {
                        return "大きい";
                    }
                };

                assertEquals("小さい", elseState.main(new String[0]));
            }

            @Test
            void elseIf句() {
                StateMentInterface elseIfState = (args) -> {
                    var a = 2;
                    if (a < 3) {
                        return "小さい";
                    } else if (a < 3) {
                        return "中くらい";
                    } else {
                        return "大きい";
                    }
                };

                assertEquals("小さい", elseIfState.main(new String[0]));
            }
        }

        @Nested
        class switchによる条件分岐 {
            @Test
            void swith式() {
                StateMentInterface switchState = (args) -> {
                    var a = 3;
                    return switch (a) {
                        case 1, 2 -> "one-two";
                        case 3 -> "three";
                        case 4 -> "four";
                        default -> "other";
                    };
                };

                assertEquals("three", switchState.main(new String[0]));
            }
        }
    }

    @Nested
    class データ構造 {
        @Nested
        class Listで値をまとめる {
            @Test
            void List() {
                var names = List.of("yamamoto", "kishida", "sugiyama");
                assertEquals("[yamamoto, kishida, sugiyama]", names.toString());
                assertEquals("kishida", names.get(1));
                assertEquals("yamamoto", names.get(0));
                assertEquals(3, names.size());
                assumeTrue(names instanceof List<String>);
            }

            @Test
            void 変更できるList() {
                var names = List.of("yamamoto", "kishida", "sugiyama");
                assertThrows(UnsupportedOperationException.class, () -> names.add("test"));
                var authors = new ArrayList<String>();
                authors.add("yamamoto");
                assertEquals("yamamoto", authors.get(0));
                authors.add("kishida");
                assertEquals("[yamamoto, kishida]", authors.toString());
                assertEquals(2, authors.size());
                authors.add("sugiyama");
                assertEquals(3, authors.size());
                authors.set(1, "naoki");
                assertEquals("[yamamoto, naoki, sugiyama]", authors.toString());
                assertThrows(IndexOutOfBoundsException.class, () -> authors.get(4));
                assertThrows(ArrayIndexOutOfBoundsException.class, () -> List.of().get(0));
            }

            @Test
            void ジェネリクスの型推論() {
                var names = List.of("yamamoto", "kishida", "sugiyama");
                var authors = new ArrayList<>(names);
                assertEquals("[yamamoto, kishida, sugiyama]", authors.toString());
            }
        }

        @Nested
        class 配列 {
            @Test
            void 配列の初期化() {
                var scores = new int[3];
                assertTrue(scores instanceof int[]);
                assertEquals(3, scores.length);
            }

            @Test
            void 要素を設定した配列の初期化() {
                var scores = new int[] { 1, 2, 3 };
                assertTrue(scores instanceof int[]);
                assertEquals(3, scores.length);
                assertEquals(1, scores[0]);
                assertEquals(2, scores[1]);
                assertEquals(3, scores[2]);
            }

            @Test
            void 配列の要素の利用() {
                var scores = new int[3];
                scores[1] = 85;
                assertEquals(85, scores[1]);
            }

            @Test
            void 多次元配列() {
                var mat = new int[2][3];
                mat[1][2] = 5;
                assertEquals(5, mat[1][2]);
                var mat2 = new int[][] { { 1, 2 }, { 3, 4, 5 } };
                assertEquals(3, mat2[1].length);
            }
        }

        @Nested
        class レコードで違う種類の値を組み合わせる {
            @Test
            void 違う種類の値をListでまとめて扱う() {
                var exam = List.of("kis", "math", 80);
                assertEquals("kis", exam.get(0));
                assertEquals(80, exam.get(2));
            }

            @Test
            void 違う種類の値をまとめて扱うレコードを定義する() {
                record Exame(String name, String subject, int score) {
                }
            }

            @Test
            void レコードのオブジェクトを生成する() {
                record Exame(String name, String subject, int score) {
                }
                var e1 = new Exame("kis", "math", 80);
                assertEquals("kis", e1.name);
                assertEquals(80, e1.score);
                assertEquals("KIS", e1.name.toUpperCase());
            }
        }

        @Nested
        class Mapで辞書を作る {
            @Test
            void Map_() {
                var fruits = Map.of("apple", "りんご", "grape", "ぶどう");
                assertEquals("ぶどう", fruits.get("grape"));
                assertNull(fruits.get("banana"));
                assertEquals("みつからない", fruits.getOrDefault("banana", "みつからない"));
                assertEquals(2, fruits.size());
                assertThrows(IllegalArgumentException.class, () -> Map.of("carot", "にんじん", "carot", "ニンジン"));
            }

            @Test
            void 変更可能なMap() {
                var animals = new HashMap<String, String>();
                animals.put("dog", "いぬ");
                animals.put("cat", "ねこ");
                assertEquals("ねこ", animals.get("cat"));
                assertNull(animals.get("fox"));
                animals.put("fox", "きつね");
                assertEquals("きつね", animals.get("fox"));
                animals.put("cat", "猫");
                assertEquals("猫", animals.get("cat"));
                assertEquals(3, animals.size());
            }
        }
    }

    @Nested
    class 繰り返し {
        @Nested
        class ループ構文 {
            @Test
            void for文の基本() {
                Function<String[], List<Object>> forState = (args) -> {
                    var array = new ArrayList<>();
                    for (int i = 0; i < 5; i++) {
                        array.add(i);
                    }
                    return array;
                };

                assertEquals(5, forState.apply(new String[0]).size());
            }

            @Test
            void for文の応用() {
                Function<Function<List<Object>, List<Object>>, List<Object>> forState = (loop) -> {
                    var array = new ArrayList<>();
                    return loop.apply(array);
                };

                Function<List<Object>, List<Object>> loop1 = (array) -> {
                    for (int i = 0; i < 5; i += 2) {
                        array.add(i);
                    }
                    return array;
                };

                Function<List<Object>, List<Object>> loop2 = (array) -> {
                    for (int i = 3; i > 0; i--) {
                        array.add(i);
                    }
                    return array;
                };

                assertEquals("[0, 2, 4]", forState.apply(loop1).toString());
                assertEquals("[3, 2, 1]", forState.apply(loop2).toString());
            }

            @Test
            void while文() {
                Function<String[], List<Object>> whileState = (args) -> {
                    var array = new ArrayList<>();
                    int i = 0;
                    while (i < 5) {
                        array.add(i);
                        i++;
                    }
                    return array;
                };

                assertEquals(5, whileState.apply(new String[0]).size());
            }

            @Test
            void ループのcontinueとbreak() {
                Function<String[], List<Object>> loopState = (args) -> {
                    var array = new ArrayList<>();
                    for (int i = 0; i < 5; i++) {
                        if (i == 2) {
                            array.add("skip");
                            continue;
                        }
                        array.add(i);
                    }
                    return array;
                };

                assertEquals("[0, 1, skip, 3, 4]", loopState.apply(new String[0]).toString());

                Function<String[], List<Object>> loopState2 = (args) -> {
                    var array = new ArrayList<>();
                    for (int i = 0; i < 5; i++) {
                        if (i == 2) {
                            array.add("finish");
                            break;
                        }
                        array.add(i);
                    }
                    return array;
                };

                assertEquals("[0, 1, finish]", loopState2.apply(new String[0]).toString());
            }
        }

        @Nested
        class ループになれる {
            @Test
            void デバッガーでループを覗く() {
                Function<String[], List<Object>> loopState = (args) -> {
                    var array = new ArrayList<>();
                    for (int i = 0; i < 5; i++) {
                        if (i != 2) {
                            array.add(i);
                            continue;
                        }
                        array.add("finish");
                        break;
                    }
                    return array;
                };

                assertEquals("[0, 1, finish]", loopState.apply(new String[0]).toString());
            }

            @Test
            void 二重ループ() {
                Function<String[], List<Object>> loopState = (args) -> {
                    var array = new ArrayList<>();
                    for (int i = 1; i <= 5; i++) {
                        for (int j = 1; j <= 9; j++) {
                            array.add(i * j);
                        }
                    }
                    return array;
                };

                assertEquals(
                        "[1, 2, 3, 4, 5, 6, 7, 8, 9, 2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45]",
                        loopState.apply(new String[0]).toString());

                Function<String[], List<Object>> loopState2 = (args) -> {
                    var array = new ArrayList<>();
                    for (int i = 1; i <= 5; i++) {
                        array.add("○".repeat(i));
                    }
                    return array;
                };

                assertEquals("[○, ○○, ○○○, ○○○○, ○○○○○]", loopState2.apply(new String[0]).toString());
            }

            @Test
            void もう少しループの練習() {

            }

            @Test
            void 迷路ゲームを作る() {
            }
        }
    }

    @Nested
    class データ構造の処理 {
        @Nested
        class データ構造を拡張for文で扱う {
            @Test
            void 基本for文でのListの要素の処理() {
                Function<String[], List<Object>> forState = (args) -> {
                    var array = new ArrayList<>();
                    var strs = List.of("apple", "banana", "grape");
                    for (int i = 0; i < strs.size(); i++) {
                        array.add(strs.get(i));
                    }
                    return array;
                };

                assertEquals("[apple, banana, grape]", forState.apply(new String[0]).toString());
            }

            @Test
            void 拡張for文によるListの要素の処理() {
                Function<String[], List<Object>> forState = (args) -> {
                    var array = new ArrayList<>();
                    var strs = List.of("apple", "banana", "grape");
                    for (String str : strs) {
                        array.add(str);
                    }
                    return array;
                };

                assertEquals("[apple, banana, grape]", forState.apply(new String[0]).toString());
            }

            @Test
            void 拡張for文による配列の要素の処理() {
                Function<String[], List<Object>> forState = (args) -> {
                    var array = new ArrayList<>();
                    var nums = new int[] { 2, 3, 5, 7 };
                    for (int num : nums) {
                        array.add(num);
                    }
                    return array;
                };

                assertEquals("[2, 3, 5, 7]", forState.apply(new String[0]).toString());
            }

            @Test
            void 値の集合の処理パターン() {
                Function<String[], List<Object>> forState = (args) -> {
                    var array = new ArrayList<>();
                    var data = List.of("yamamoto", "kis", "sugiyama");
                    for (var s : data) {
                        if (s.length() > 5) {
                            array.add(s);
                        }
                    }
                    return array;
                };

                assertEquals("[yamamoto, sugiyama]", forState.apply(new String[0]).toString());

                Function<String[], List<Object>> forState2 = (args) -> {
                    var array = new ArrayList<>();
                    var data = List.of("yamamoto", "kis", "sugiyama");

                    var result = 0;
                    for (var s : data) {
                        if (s.length() > 5) {
                            result++;
                        }
                    }
                    array.add(result);
                    return array;
                };

                assertEquals("[2]", forState2.apply(new String[0]).toString());
            }
        }

        @Nested
        class Stream_ {
            @Test
            void IntelliJIDEAによるStreamへの変換() {
                var data = List.of("yamamoto", "kis", "sugiyama");
                var result = data.stream().filter(s -> s.length() > 5).collect(Collectors.toCollection(ArrayList::new));
                assertEquals("[yamamoto, sugiyama]", result.toString());

                var result2 = (int) data.stream().filter(s -> s.length() >= 5).count();
                assertEquals(2, result2);
            }

            @Test
            void Streamソース() {
                var names = List.of("yamamoto", "kis", "sugiyama");
                assertEquals("[yamamoto, kis, sugiyama]", names.toString());
                var strarray = new String[] { "test", "hello", "world" };
                assertEquals("[test, hello, world]", Arrays.stream(strarray).toList().toString());
                assertEquals("[test, hello, world]", Stream.of(strarray).toList().toString());
                assertEquals("[test, hello, world]", Stream.of("test", "hello", "world").toList().toString());
                var resutl = """
                        test
                        hello
                        world
                        """.lines().toList();
                assertEquals("[test, hello, world]", resutl.toString());
            }

            @Test
            void 終端処理() {
                var names = List.of("yamamoto", "kis", "sugiyama");
                assertEquals("[yamamoto, kis, sugiyama]", names.stream().toList().toString());
                assertEquals(3, names.stream().count());
                assertFalse(names.stream().allMatch(s -> s.contains("y")));
                assertTrue(names.stream().anyMatch(s -> s.contains("y")));
                assertFalse(names.stream().noneMatch(s -> s.contains("y")));
                assertTrue(names.stream().noneMatch(s -> s.contains("n")));
                assertEquals("yamamotokissugiyama", names.stream().collect(Collectors.joining()));
                assertEquals("yamamoto/kis/sugiyama", names.stream().collect(Collectors.joining("/")));
                assertEquals("[yamamoto, kis, sugiyama]", names.stream().collect(Collectors.toList()).toString());
            }

            @Test
            void 中間処理() {
                var names = List.of("yamamoto", "kis", "sugiyama");
                assertEquals("[yamamoto, sugiyama]", names.stream().filter(s -> s.length() > 5).toList().toString());
                assertEquals("[YAMAMOTO, KIS, SUGIYAMA]", names.stream().map(s -> s.toUpperCase()).toList().toString());

                assertEquals("[kis, sugiyama]", names.stream().skip(1).toList().toString());
                assertEquals("[yamamoto, kis]", names.stream().limit(2).toList().toString());
                assertEquals("[kis, sugiyama, yamamoto]", names.stream().sorted().toList().toString());
                assertEquals("[yamamoto, kis, sugiyama]", names.stream().distinct().toList().toString());
                assertEquals("[abc, cde]", Stream.of("abc", "cde", "abc").distinct().toList().toString());
            }

            @Test
            void Optional() {
                var names = List.of("yamamoto", "kis", "sugiyama");
                assertEquals("Optional[yamamoto]", names.stream().findAny().toString());
                assertEquals("Optional.empty", Stream.of().findAny().toString());
                var o = Optional.of("test");
                assertEquals("Optional[test]", o.toString());
                assertEquals("Optional.empty", Optional.empty().toString());
                assertEquals("test", o.get().toString());
                assertThrows(NoSuchElementException.class, () -> Optional.empty().get());
                assertEquals("無", Optional.empty().orElse("無"));
                assertEquals("test", o.orElse("無"));
                assertEquals("TEST", o.map(s -> s.toUpperCase()).orElse("無"));
                assertTrue(o.isPresent());
                assertFalse(o.isEmpty());
                o.ifPresent(s -> assertEquals("test", s));
            }
        }

        @Nested
        class 基本型のStream処理 {
            @Test
            void IntStreamで整数の処理() {
                var nums = new int[] { 2, 5, 3 };
                assertEquals(10, IntStream.of(nums).sum());
                assertEquals(10, IntStream.range(0, 10).toArray().length);
                assertEquals(11, IntStream.rangeClosed(0, 10).toArray().length);
                assertEquals(10, IntStream.iterate(0, i -> i < 10, i -> i + 1).toArray().length);
                assertEquals(10, IntStream.iterate(123, i -> (i * 211 + 2111) % 1000).limit(10).toArray().length);
                assertEquals(10, new Random().ints(10, 0, 10).toArray().length);
                assertEquals(6, IntStream.of(nums).map(n -> n * 2).toArray()[2]);
                assertEquals(3, IntStream.of(nums).filter(n -> n < 5).toArray()[1]);
                assertEquals(5, IntStream.of(nums).sorted().toArray()[2]);
            }

            @Test
            void StreamとIntStreamの行き来() {
                var nums = new int[] { 2, 5, 3 };
                var names = List.of("yamamoto", "kis", "sugiyama");
                assertEquals("[**, *****, ***]", IntStream.of(nums).mapToObj(n -> "*".repeat(n)).toList().toString());
                assertEquals(3, names.stream().mapToInt(s -> s.length()).toArray().length);
            }
        }
    }

    @Nested
    class メソッド {

        @Nested
        class メソッドの宣言 {
            @Test
            void メソッドの宣言() {
                class Method {
                    String greeting(String name) {
                        return "Hello, " + name;
                    }

                    int twice(int x) {
                        return x * 2;
                    }
                }

                var method = new Method();
                assertEquals("Hello, Yamamoto", method.greeting("Yamamoto"));
                assertEquals("Hello, kis", method.greeting("kis"));
                assertEquals(10, method.twice(5));
            }

            @Test
            void staticメソッドの宣言() {
                class StaticMethod {
                    static int twice(int x) {
                        return x * 2;
                    }
                }

                assertEquals(10, StaticMethod.twice(5));
            }

            @Test
            void インスタンスメソッドの宣言() {
                class InstanceMethodSample {
                    record Student(String name, int englishScore, int mathScore) {
                        int average() {
                            return (englishScore + mathScore) / 2;
                        }
                    }

                    static int average(Student s) {
                        return (s.englishScore + s.mathScore) / 2;
                    }
                }

                var student = new InstanceMethodSample.Student("kis", 60, 80);
                assertEquals(70, InstanceMethodSample.average(student));
                assertEquals(70, student.average());
            }
        }

        @Nested
        class ラムダ式とメソッド参照 {
            @Test
            void ラムダ式() {
                assertEquals(3, IntStream.range(0, 3).map(x -> x * 2).toArray().length);
            }

            @Test
            void メソッド参照() {
                class StaticMethod {
                    static int twice(int x) {
                        return x * 2;
                    }
                }
                assertEquals(6, IntStream.range(0, 3).map(x -> StaticMethod.twice(x)).sum());
                assertEquals(6, IntStream.range(0, 3).map(StaticMethod::twice).sum());
            }
        }

        @Nested
        class メソッドの使いこなし {
            @Test
            void メソッドのオーバーロード() {

            }

            @Test
            void メソッド呼び出しの組み合わせ() {
                assertEquals(30, "tomato".repeat(5).length());
                assertEquals("買い物はトマトとレタスで600円", "買い物は%sで%d円".formatted("トマトとレタス", 600));
                var items = String.join("と", "トマト", "レタス");
                assertEquals("トマトとレタス", items);
                assertEquals("買い物はトマトとレタスで600円", "買い物は%sで%d円".formatted(items, 600));
            }

            @Test
            void 再帰とスタック() {
                class RecLoop {
                    static int loop(int i) {
                        if (i >= 5) {
                            return i;
                        }
                        return loop(i + 1);
                    }
                }

                assertEquals(5, RecLoop.loop(0));
            }
        }
    }

    @Nested
    class 入出力と例外 {
        @Nested
        class ファイルアクセスと例外 {
            class WriteFile {
                static void main(Path p) throws IOException {
                    var message = """
                            test
                            message
                            """;
                    Files.writeString(p, message);
                }
            }

            class ReadFile {
                static String main(Path p) throws IOException {
                    var content = Files.readString(p);
                    return content;
                }
            }

            @Test
            void ファイル書き込み(@TempDir Path tempDir) throws IOException {
                var p = tempDir.resolve("test.txt");
                WriteFile.main(p);
                assertTrue(Files.exists(p));
            }

            @Test
            void ファイル読み込み(@TempDir Path tempDir) throws IOException {
                var p = tempDir.resolve("test.txt");
                WriteFile.main(p);
                var content = ReadFile.main(p);
                assertTrue(Files.exists(p));
                assertEquals("test\nmessage\n", content);
            }

            @Test
            void 例外(@TempDir Path tempDir) throws IOException {
                var p = tempDir.resolve("test.txt");
                WriteFile.main(p);
                assertThrows(NoSuchFileException.class, () -> ReadFile.main(p.resolve("test.txta")));
            }
        }

        @Nested
        class ネットワークでコンピュータの外の世界と関わる {
            @Test
            void サーバーとクライアント() {
                class SimpleServer {
                    public static void main() throws IOException {
                        var server = new ServerSocket(1600);
                        System.out.println("Waiting...");
                        Socket soc = server.accept();
                        System.out.println("connect from " + soc.getInetAddress());
                        InputStream input = soc.getInputStream();
                        System.out.println(input.read());
                        input.close();
                        soc.close();
                    }
                }

                class SimpleClient {
                    public static void main() throws IOException {
                        var soc = new Socket("localhost", 1600);
                        OutputStream output = soc.getOutputStream();
                        output.write(234);
                        output.close();
                        soc.close();
                    }
                }
            }

            @Test
            void try_with_resources() {
                class SimpleServer {
                    public static void main() throws IOException {
                        var server = new ServerSocket(1600);
                        System.out.println("Waiting...");
                        try (Socket soc = server.accept();
                                InputStream input = soc.getInputStream()) {
                            System.out.println("connect from " + soc.getInetAddress());
                            System.out.println(input.read());
                        }
                    }
                }

                class SimpleClient {
                    public static void main() throws IOException {
                        try (var soc = new Socket("localhost", 1600);
                                OutputStream is = soc.getOutputStream()) {
                            is.write(234);
                        }
                    }
                }
            }
        }

        @Nested
        class webの裏側を見てみる {
            @Test
            void HTTPクライアント() throws IOException {
                class WebClient {
                    public static void main() throws IOException {
                        var domain = "example.com";
                        try (var soc = new Socket(domain, 80);
                                var pw = new PrintWriter(soc.getOutputStream());
                                var isr = new InputStreamReader(soc.getInputStream());
                                var bur = new BufferedReader(isr)) {
                            pw.println("GET / HTTP/1.1");
                            pw.println("Host: " + domain);
                            pw.println();
                            pw.flush();
                            bur.lines()
                                    .limit(18)
                                    .forEach(System.out::println);
                        }
                    }
                }
            }

            @Test
            void HTTPSで安全なWebアクセス() throws IOException {
            }

            @Test
            void Webクライアントライブラリ() throws IOException {
                class WebClient2 {
                    public static void main() throws IOException, InterruptedException {
                        HttpClient client = HttpClient.newHttpClient();
                        URI uri = URI.create("https://example.com");
                        HttpRequest req = HttpRequest.newBuilder(uri).build();
                        HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());
                        String body = res.body();
                        body.lines()
                                .limit(5)
                                .forEach(System.out::println);
                    }
                }
            }

            @Test
            void Webサーバーを作る() throws IOException {
                class WebServer {
                    public static void main() throws IOException {
                        var server = new ServerSocket(8880);
                        System.out.println("Waiting...");
                        for (;;) {
                            try (Socket soc = server.accept();
                                    var isr = new InputStreamReader(soc.getInputStream());
                                    var bur = new BufferedReader(isr);
                                    var w = new PrintWriter(soc.getOutputStream())) {
                                System.out.println("connect from " + soc.getInetAddress());
                                bur.lines()
                                        .takeWhile(line -> !line.isEmpty())
                                        .forEach(System.out::println);
                                w.println("""
                                              HTTP/1.1 200 OK
                                              Content-Type: text/html

                                              <html><head><title>Hello</title></head>
                                              <body><h1>Hello</h1></body></html>
                                        """);
                            }
                        }
                    }
                }
            }
        }
    }

    @Nested
    class 処理の難しさの段階 {
        @Nested
        class ループの難しさの段階 {
            @Test
            void 他のデータを参照するループ() {
                Function<String[], String> loop = (String[] args) -> {
                    var data = "abcccbaabcc";

                    var builder = new StringBuilder();
                    for (int i = 0; i < data.length(); i++) {
                        char ch = data.charAt(i);
                        if (i > 0 && ch == data.charAt(i - 1)) {
                            continue;
                        }
                        builder.append(ch);
                    }
                    var result = builder.toString();
                    return result;
                };

                assertEquals("abcbabc", loop.apply(new String[] {}));

                Function<String[], String> loop2 = (String[] args) -> {
                    var data = "abcccbaabcc";

                    char prev = 0;
                    var builder = new StringBuilder();
                    for (char ch : data.toCharArray()) {
                        if (ch == prev) {
                            continue;
                        }
                        builder.append(ch);
                        prev = ch;
                    }
                    var result = builder.toString();
                    return result;
                };

                assertEquals("abcbabc", loop2.apply(new String[] {}));
            }

            @Test
            void 隠れた状態を扱うループ() {
                Function<String, String> runLengthCompression = (String args) -> {
                    final var COUNTER_BASE = -1;
                    var data = args;

                    var count = COUNTER_BASE;
                    char prev = 0;
                    var builder = new StringBuilder();
                    for (var ch : data.toCharArray()) {
                        if (prev == ch) {
                            count++;
                            if (count == 9) {
                                builder.append('9');
                                count = COUNTER_BASE;
                                prev = 0;
                            }
                        } else {
                            if (count >= 0) {
                                builder.append((char) ('0' + count));
                                count = COUNTER_BASE;
                            }
                            builder.append(ch);
                            prev = ch;
                        }
                    }
                    if (count >= 0) {
                        builder.append((char) ('0' + count));
                    }
                    var result = builder.toString();
                    return result;
                };

                assertEquals("ab0c", runLengthCompression.apply("abbc"));
                assertEquals("ab0c1ba2bc9cd1", runLengthCompression.apply("abbcccbaaaabccccccccccccddd"));
            }
        }

        @Nested
        class 状態遷移と正規表現 {
            @Test
            void 状態遷移の管理とenum() {
                enum FloatState {
                    START, INT, FRAC_START, FRAC, ZERO
                }
                Function<String, Boolean> check = (data) -> {
                    var state = FloatState.START;
                    for (char ch : data.toCharArray()) {
                        switch (state) {
                            case START -> {
                                if (ch == '0') {
                                    state = FloatState.ZERO;
                                } else if (ch >= '1' && ch <= '9') {
                                    state = FloatState.INT;
                                } else {
                                    return false;
                                }
                            }
                            case ZERO -> {
                                if (ch == '.') {
                                    state = FloatState.FRAC_START;
                                } else {
                                    return false;
                                }
                            }
                            case INT -> {
                                if (ch >= '0' && ch <= '9') {
                                    state = FloatState.INT;
                                } else if (ch == '.') {
                                    state = FloatState.FRAC_START;
                                } else {
                                    return false;
                                }
                            }
                            case FRAC_START, FRAC -> {
                                if (ch >= '0' && ch <= '9') {
                                    state = FloatState.FRAC;
                                } else {
                                    return false;
                                }
                            }
                        }
                    }
                    return switch (state) {
                        case ZERO, INT, FRAC -> true;
                        default -> false;
                    };
                };

                assertFalse(check.apply(""));
                assertFalse(check.apply("012"));
                assertFalse(check.apply(".12"));
                assertFalse(check.apply("12."));
                assertFalse(check.apply("1.2.3"));
                assertFalse(check.apply("1..3"));
                assertTrue(check.apply("0"));
                assertTrue(check.apply("12"));
                assertTrue(check.apply("12.3"));
                assertTrue(check.apply("0.3"));
                assertTrue(check.apply("12.30"));
            }

            @Test
            void 正規表現() {
                final Pattern pat = Pattern.compile("(0|[1-9][0-9]*)(\\.[0-9]+)?");
                Function<String, Boolean> check = (data) -> {
                    Matcher mat = pat.matcher(data);
                    return mat.matches();
                };

                assertFalse(check.apply(""));
                assertFalse(check.apply("012"));
                assertFalse(check.apply(".12"));
                assertFalse(check.apply("12."));
                assertFalse(check.apply("1.2.3"));
                assertFalse(check.apply("1..3"));
                assertTrue(check.apply("0"));
                assertTrue(check.apply("12"));
                assertTrue(check.apply("12.3"));
                assertTrue(check.apply("0.3"));
                assertTrue(check.apply("12.30"));
            }
        }

        @Nested
        class スタックとキュー {
            @Test
            void ツリーの探索() {
                class TraverseDeep {
                    public static void main() {
                        int[][] map = {
                                { 1, 1, 1, 1, 1, 1, 1 },
                                { 1, 0, 1, 0, 0, 0, 1 },
                                { 1, 0, 0, 0, 1, 1, 1 },
                                { 1, 0, 1, 0, 0, 2, 1 },
                                { 1, 1, 1, 1, 1, 1, 1 }
                        };
                        traverse(map, 1, 1);
                        char[] ch = { '.', '*', 'G', 'o' };
                        for (int[] row : map) {
                            for (int cel : row) {
                                System.out.print(ch[cel]);
                            }
                            System.out.println();
                        }
                    }

                    static boolean traverse(int[][] map, int curX, int curY) {
                        switch (map[curY][curX]) {
                            case 0:
                                break;
                            case 2:
                                return true;
                            default:
                                return false;
                        }
                        map[curY][curX] = 3;
                        if (traverse(map, curX + 1, curY) ||
                                traverse(map, curX - 1, curY) ||
                                traverse(map, curX, curY + 1) ||
                                traverse(map, curX, curY - 1)) {
                            return true;
                        }
                        map[curY][curX] = 0;
                        return false;
                    }
                }
            }

            @Test
            void メソッドの先呼び出しをスタックを使った処理に置き換える() {
                class TraverseDeep {
                    public static void main() {
                        int[][] map = {
                                { 1, 1, 1, 1, 1, 1, 1 },
                                { 1, 0, 1, 0, 0, 0, 1 },
                                { 1, 0, 0, 0, 1, 1, 1 },
                                { 1, 0, 1, 0, 0, 2, 1 },
                                { 1, 1, 1, 1, 1, 1, 1 }
                        };
                        traverse(map, 1, 1);
                        char[] ch = { '.', '*', 'G', 'o' };
                        for (int[] row : map) {
                            for (int cel : row) {
                                System.out.print(ch[cel]);
                            }
                            System.out.println();
                        }
                    }

                    static boolean traverse(int[][] map, int curX, int curY) {
                        record Position(int x, int y) {
                        }

                        var stack = new ArrayDeque<Position>();
                        stack.push(new Position(curX, curY));
                        for (Position p; (p = stack.pollFirst()) != null;) {
                            switch (map[p.y()][p.x()]) {
                                case 0:
                                    break;
                                case 2:
                                    return true;
                                default:
                                    return false;
                            }
                            map[p.y()][p.x()] = 3;
                            stack.push(new Position(p.x() + 1, p.y()));
                            stack.push(new Position(p.x() - 1, p.y()));
                            stack.push(new Position(p.x(), p.y() + 1));
                            stack.push(new Position(p.x(), p.y() - 1));
                        }
                        return false;
                    }
                }
            }
        }
    }

    @Nested
    class クラスとインタフェース {
        @Nested
        class クラス {
            @Test
            void クラス() {
                class ClassSample {
                    record Student(String name, int score) {
                    }

                    public static Student main() {
                        Student s = new Student("Taro", 80);
                        return s;
                    }
                }

                assertEquals("Taro", ClassSample.main().name());
            }

        }

        @Nested
        class インタフェース {
            @Test
            void インタフェースが欲しい状況() {
                class InterfaceSample {
                    record Student(String name, int score) {
                    }

                    record Teacher(String name, String subject) {
                    }

                    public static void main() {
                        var people = List.of(new Student("kis", 80), new Teacher("hosoya", "Math"));
                        for (var p : people) {
                            var n = p instanceof Student s ? s.name() : p instanceof Teacher t ? t.name() : "___";
                            System.out.println("こんにちは%sさん".formatted(n));
                        }
                    }
                }
            }

            @Test
            void インタフェースを使ってメソッドを統一的に扱う() {
                class InterfaceSample {
                    interface Named {
                        String name();
                    }

                    record Student(String name, int score) implements Named {
                    }

                    record Teacher(String name, String subject) implements Named {
                    }

                    public static void main() {
                        var people = List.of(new Student("kis", 80), new Teacher("hosoya", "Math"));
                        for (var p : people) {
                            System.out.println("こんにちは%sさん".formatted(p.name()));
                        }
                    }
                }
            }

            @Test
            void 必要なメソッドを実装していないときのエラー() {
                class InterfaceSample {
                    interface Named {
                        String name();
                    }

                    record Student(String name, int score) implements Named {
                    }

                    record Teacher(String name, String subject) implements Named {
                    }

                    static class Passenger implements Named {
                        @Override
                        public String name() {
                            return "通りすがり";
                        }

                    }

                    public static void main() {
                        var people = List.of(new Student("kis", 80), new Teacher("hosoya", "Math"),
                                new Passenger());
                        for (var p : people) {
                            System.out.println("こんにちは%sさん".formatted(p.name()));
                        }
                    }
                }

            }
        }

        @Nested
        class ラムダ式と関数型インタフェース {

            @Test
            void 関数型インタフェース() {
                @FunctionalInterface
                interface Named {
                    String name();

                    default String greeting() {
                        return "こんにちは%sさん".formatted(name());
                    }
                }

                var student = new Named() {
                    @Override
                    public String name() {
                        return "kis";
                    }
                };

                assertEquals("こんにちはkisさん", student.greeting());
            }

            @Test
            void 標準APIで用意されている関数型インタフェース() {
                Function<String, String> greeting = s -> "こんにちは%sさん".formatted(s);
                assertEquals("こんにちはkisさん", greeting.apply("kis"));

            }

        }

        @Nested
        class クラスとファイル {
        }
    }

    @Nested
    class 継承 {

    }

}

interface CalcInterface {
    int div(int a, int b);
}

interface StateMentInterface {
    String main(String[] args);
}
